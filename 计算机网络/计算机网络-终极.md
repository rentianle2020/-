# 计算机网络-终极



# 一、浏览器

浏览器：多功能客户端软件，通过"http:"/"ftp:"来判断使用哪种功能



### **生成HTTP请求**

请求行：GET/POST方法，URL，HTTP版本

**请求头**

消息体（message body）



状态行：HTTP版本，状态码，响应短语（用来解释状态码）

<img src="C:/Users/%E4%B9%90%E4%B9%90%E5%A4%A7%E5%93%A5%E5%93%A5/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/image-20210904214355661.png" alt="image-20210904214355661" style="zoom: 33%;" />	

**消息头**

消息体



### 向DNS服务器查询Web服务器的IP地址

IP：32bit的数字；1通过IP判断服务器的位置，从而将消息发送过去

10.11.12.13/255.255.255.0：IP地址主体+子网掩码，子网掩码为1的部分表示网络号，为0的部分表示主机号；判断目标IP与当前IP是否位于同一个子网



### 全世界DNS服务器的大接力

每台计算机的Socket库中，都有DNS解析器（resolver）组件，它来执行域名解析

调用socket库gethostbyname --> 调用操作系统内部的协议栈 --> 网卡发送UDP信息到DNS服务器



DNS服务器从域名与IP地址的对照表中找到相应记录，并返回

<img src="C:/Users/%E4%B9%90%E4%B9%90%E5%A4%A7%E5%93%A5%E5%93%A5/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/image-20210904215534128.png" alt="image-20210904215534128" style="zoom:33%;" />	

有时不需要从最上级根域开始查找，因为DNS服务器有缓存功能，可以记住查询过的域名



### 委托协议栈发送消息

按照指定顺序调用Socket库，向协议栈发出委托

1. 创建套接字

   返回描述符，计算机内部识别套接字的机制

2. 连接到服务端的套接字

   connect，指定描述符、服务器IP和端口号（让通信的另一方识别出套接字）

   连接完成后，将对方的IP和端口号保存在Socket中，就可以开始通信了

3. 收发数据

   write

   read，指定存放消息的内存地址

4. 断开连接，删除套接字

   close



# 二、用电信号传输TCP/IP—协议栈&网卡

上层向下层委派工作

<img src="C:/Users/%E4%B9%90%E4%B9%90%E5%A4%A7%E5%93%A5%E5%93%A5/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/image-20210904220746619.png" alt="image-20210904220746619" style="zoom: 40%;" />	



### 创建套接字

调用 `socket()`

协议栈分配存放套接字控制信息所需的内存空间

返回描述符，应用通过描述符来区分协议栈中的套接字



### 连接服务器

调用 `socket.connect()`

连接实际上就是双方交换`Socket控制信息`

在连接过程中完成缓冲区的内存分配，这块区域用于临时存放要收发的数据

扩展：`三次挥手`



**控制信息**

- TCP头部中的控制信息（端口号，序号，ACK号）格式必须遵守的

- Socket中的控制信息，操作系统不同，协议栈的具体实现也不同



### 收发数据

调用 `socket.write()`

协议栈将数据放在发送缓冲区，累计一定量再一起发送。（需要平衡发送量和发送频率）

收到消息，协议栈检查TCP头部和内容，判断数据是否有丢失，没有问题就返回ACK；将数据块暂存到接收缓冲区，并按顺序连接起来还原出原始的数据



调用`socket.read()`

协议栈尝试从接收缓冲区中取出数据传递给应用程序，协议栈找到合适的时机向发送方发送窗口更新



**网络包长度**

MTU Maximum Transmission Unit：一个网络包的最大长度，以太网中一般为 `1500字节`

MSS Maximum Segment Size：去掉IP和TCP头部后，网络包容纳数据的最大长度



**ACK和序号**

连接时确定起始序号，每次发送包含数据起始序号和数据大小

返回ACK号来告诉发送方自己收到了序号为多少的数据

如：起始需要为1，发送需要1 长度1460字节；返回ACK 1461

<img src="C:/Users/%E4%B9%90%E4%B9%90%E5%A4%A7%E5%93%A5%E5%93%A5/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/image-20210904222319146.png" alt="image-20210904222319146" style="zoom:43%;" />	

通过ACK和序号的机制，保证了数据的 `有序传输 ` 以及 `丢失重传`

长时间没有等待到ACK，重传；一直ACK以前的序号，说明没接收到新的数据包，重传

扩展： `快速重传`



**根据网络包平均往返事件，调整ACK号的等待时间**

网络拥塞导致ACK慢，发送方需要调整重传等待时间，避免无谓的重传

扩展：`拥塞控制` 



**使用窗口有效管理ACK号**

发送方不用等待ACK返回，继续发送

接收方可以将ACK号和窗口大小放在一个包中返回

<img src="C:/Users/%E4%B9%90%E4%B9%90%E5%A4%A7%E5%93%A5%E5%93%A5/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/image-20210904222715114.png" alt="image-20210904222715114" style="zoom: 33%;" />	



### 从服务器断开连接并删除套接字

调用 `socket.close()`

完成数据发送的一方会发起断开过程

断开连接后，套接字并不会被立刻删除，为了防止误操作。

如：服务器FIN，客户端ACK；客户端立即删除套接字；服务端没有收到ACK，再次FIN；客户端已将相同端口重新分配；该应用被FIN掉了

扩展：`四次挥手`



### IP与以太网的包收发操作

IP模块负责添加两个头部

IP头部：将包发往目的地所需的控制信息

MAC头部：将包传输至最近路由器所需的控制信息



封装好的网络包是一串0和1组成的数组信息，传递给网卡。

网卡将数字信息转换为电信号/光信号，通过网线（或光纤）发送出去，信号到达路由器等转发设备，一步步送达接收方。



通过路由表得到IP地址，使用ARP查询MAC地址（ARP缓存保存MAC地址）

接收方IP模块判断包是否有错误，发生错误则通过ICMP消息将错误告知发送方。



以太网：为了让多台计算机能够自由&廉价的互相通信，而设计的通信技术

以太网中的本质就是一根网线（wifi则为无线），接收设备通过判断信号中的MAC头部，决定是否抛弃/接收此包。



### 用UDP协议收发数据的操作

263