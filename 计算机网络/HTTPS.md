> mansion sick equip legal valid yard fire hunt useless lens excess shed
>
> 0x769bcC0925351EA67488Fa9ee0f56776b0a6C324



# HTTPS原理



如果不加密/单纯的对称加密，报文很容易直接被劫持/通过劫持的对称密钥解密。

为了防止中间人攻击，TLS协议在TCP协议之上出现，保证安全的报文传输。



**问题1：如何加密？**

服务器通过RSA等算法生成公钥&私钥，公钥是面向所有人开放的，而私钥只保留在服务器内部，不能外泄。

公钥和私钥是成对出现的，私钥可以解密公钥加密的信息，公钥也可以解密私钥加密的信息。

通过获取服务器的公钥，客户端可以通过该公钥加密传输的报文信息，使得只有服务器可以通过它的私钥解密这段信息。



**问题2：非对称加密&对称加密同时使用？**

HTTPS的同时实用了两种加密方式，非对称加密&对称加密。

因为非对称加密解密的过程是更耗时的，所以只有在handshake时使用，而握手成功后的所有报文传输则都是采用对称加密的方式。

我们只要保证这个后续交流使用的对称加密的密钥，只有客户端&服务端知道，即可。如何做到？

1. 客户端获得服务器公钥
2. 生成随机数，通过公钥加密，将加密后的信息发送给服务器，这段随机数也叫做“预主密钥（premaster secret）”
3. 服务器通过私钥解密，获得随机数；结合上之前交换的两个明文随机数，生成对称加密密钥（会话密钥）；客户端生成同样的会话密钥
4. 双方用相同的会话密钥加密“已完成”报文，发送给对方。
5. 后续的过程，双方都通过这个会话密钥进行加密通话



**问题3：在这种情况下，中间人可否冒充服务器？**

情况1：中间人也能得知服务器的公钥，通过该公钥去骗客户端。但因为中间人无法得知私钥，所以根本无法解密“预主密钥”，从而无法完成handshake

情况2：中间人通过RSA算法生成自己的key pair，装成服务器，和客户端完成handshake。这时候，CA就介入，向客户端证明，和你通话的服务器提供的publicKey是真实有效属于这个服务器的，而不是由黑客服务器生成的。



**问题4：CA原理**

certificate由CA颁发，包含：

1. certificate data：网站的域名，CA的公钥，网站的公钥，hash方法，哈希值...
2. 一段签名signature（*sha256WithRSAEncryption*）

签名signature是由CA先hash再私钥加密的，我们通过CA的公钥解密该签名，获得哈希值1；通过CA提供的哈希方法，客户端自己再计算一下整个certificate data的哈希值，获得哈希值2

然后通过相同的hash方法获得哈希值，最后和certificate中的哈希值对比。如果相同，说明这个certificate是由CA通过privateKey加密的，而且certificate中的信息没有被篡改过。

我们是否信任颁发这个certificate的CA？Browser内部保存了一系列RootCA，我们可以查看浏览器是否信任该CA。

