### 2022/3/28

**功能性需求**

1. 选择urls
2. fetcher去指定url的html文件中拿所需的数据
3. 将数据保存到数据库中



**数据去重**

大文件通常需要哈希算法对比，简单数据就直接对比某个唯一键值。



**注意事项**

- 通过网站中的robots.txt file，检查是否允许爬取

- re-visit policy 定期检查网页更新

- pliteness policy 不要让对方网站过度过载；如果需要并行爬虫，请求之间设置间隔

选择爬虫网站和需要的数据



**选择爬取目标**

丝芙兰：爬取困难，都是使用JS完成的动态页面；且口红名字皆为英文，不是优先需要的信息。



挑选出3个品牌官网，使用Jousp试着去爬取到一些信息

https://www.maccosmetics.com.cn/products/13854

https://www.yslbeautycn.com/makeup-lips-and-nails

https://www.giorgioarmanibeauty.cn/LIPS



### 2022/3/29

**统一爬虫接口，Fetcher Interface**

- fetch()
- getBrandName() --> 用于Spring的策略模式

因为每个Brand的爬取方式都不太一样，实现类为{BrandName}Fetcher



**确定口红的基本属性**

口红作为一个Entity

- 名字
- 价格
- 图片
- 色号 (名字，RGB) --> 一对多，色号作为一个Entity
- 品牌（名字，官网）--> 多对一，品牌作为一个Entity



### 2022/3/30

docker建立口红数据库(开发环境)，Navicat远程连接，使用JPA将爬虫信息输入数据库

docker run --name lipstick-mysql -e MYSQL_ROOT_PASSWORD={PASSWORD} -p 3306:3306 -d mysql 



**解决Armani爬取问题**

Armani网页是动态JS加载的，所以不能使用Jsoup直接获取静态HTML网页。

使用HtmlUnit，开启JS支持，等待JS加载完毕后，拿到HTML，再交给Jsoup解析。

​                 

**优化fetch()方法执行过程**

1. 获取document --> 可封装
2. 获取包含每个口红div的list
3. 遍历list，从中获取口红信息(产品名字，价格，背景图) --> 可封装
4. 获取口红的颜色栏，再遍历每个颜色(Hex rgb，色号名字) --> 可封装
5. 将口红色号加入当前口红(调用addColor方法，互相添加依赖)



**通过brandName获取Fethcer类**

Map + 策略模式

```java
@Component
public class FetcherFactory {

    private final Map<String, Fetcher> fetcherMap;

    public FetcherFactory(List<Fetcher> fetcherList) {
        fetcherMap = new HashMap<>();
        for(var fetcher : fetcherList){
            fetcherMap.put(fetcher.getBrandName(),fetcher);
        }
    }

    public Fetcher getFetcher(String brandName){
        return fetcherMap.get(brandName);
    }
}
```



### 2022/3/31

完成3个品牌从爬虫到数据库的存储

完成口红产品的存储和获取接口。



**JPA通过foreign key查询，出现JSON循环解析**

解决方法：@JsonManagedReference and @JsonBackReference



**HtmlUnit日志过多**

解决方法：YAML设置关闭即可，毕竟它的日志打印也是依赖于common-log的

```yaml
logging:
  level:
    root: info
    com:
      gargoylesoftware: off
```



### 2022/4/1

使用@ControllerAdvice统一异常处理

享受清明假期~



### 2022/4/6

**建立前端项目并**

使用React作为JS框架（使用functional component和hook的搭配）

https://reactjs.org/

使用tailwindcss作为CSS框架（utility first，快速上手）

https://tailwindcss.com/

使用React Router v6完成前端路由

https://reactrouter.com/docs/en/v6

v5到v6的变动：https://betterprogramming.pub/whats-new-in-react-router-v6-31930f4aae4c



**完成简单的首页绘制**



**git管理**

前后端项目使用git管理版本，并上传github。

等全部完成后，将密码等信息保护起来，并开源。



### 2022/4/7

**使用axios发送REST请求**

https://axios-http.com/

axios.create()设置BaseUrl，然后调用get()方法从后端拿信息

使用map()将data渲染为dom，完成品牌界面和口红界面的显示。



**爬虫bug**

YSL官网爬虫图片为Loading...，需要等JS加载。

但使用HtmlUnit等待JS渲染会报bug，解决不了，暂时不管了。



### 2022/4/8

**引入heroicons作为svg库，以组件方式importsvg图标**

https://heroicons.com/



**完成口红细节页面绘制**

支持对色号的点赞，点踩，收藏的基本功能。信息暂存在localStorage，等有了用户功能后再和后端交互。



**完成搜索模态窗口的绘制**

点击搜索框跳出模态窗口，默认显示最近搜索，输入后实时显示全文搜索结果。

准备引入ElasticSearch作为后端搜索引擎，如果搜索速度不够，就要换成algolia试试了。

利用e.stopPropagation()，点击背景可以退出模态窗口，而点击模态窗口内部不会因冒泡而触发退出。



### 2022/4/12

**引入Elasticsearch作为搜索引擎(数据库)**

https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html

查看springboot中es的使用版本为<elasticsearch.version>7.15.2</elasticsearch.version>

所以，服务器端的elasticsearch需要<=该版本，否则会出现疑难bug。



使用Spring Data Elasticsearch提供的功能

使用@Document，@Id，@Field完成对索引的映射

Repository继承ElasticsearchRepository后，CRUD完全交由Spring Data处理



### 2022/4/13

**实现基础的口红查询，前后端交互**

使用Elasticsearch提供的类库

1. 前端请求的查询属性field和查询内容term
2. 自定义QueryBuilder和SearchRequest，用于创建查询请求
3. 返回SearchResponse，从中获取所有SearchHit并返回给前端。



### 2022/4/14

**扩充搜索功能**

boolQuery + rangeQuery：根据HSB值，区间搜索相似色号（近似的RBG区间，并不代表渐变的相似颜色，所以要使用HSB值）

matchBoolPrefixQuery：根据分词匹配+最后一个单词前缀的方式，匹配搜索色号/系列名



**引入React Color组件，实现选颜色搜索相似口红色号的功能**

https://casesandberg.github.io/react-color/



**还需要进一步对Elasticsearch的建模进行改动；在保持后端速度的同时，让前端的返回结果更加直观。**



### 2022/4/15

**完成所有搜索功能**

可以按照名字搜索，也可以按照颜色搜索

搜索结果为按照品牌名分类Map，按照系列和色号的不同标注不同的标识（系列使用一个icon，色号使用圆形的颜色div）

点击搜索结果跳转至该口红系列，如果点击的是色号，则默认选中该色号



**整理后端代码**

封装DTO，重命名个别REST接口，让代码更整洁



### 2022/4/19

**引入Spring Security用于Authroization & Authentication**

https://docs.spring.io/spring-security/reference/servlet/



**添加JWT分发Filter**

继承UsernamePasswordAuthenticationFilter，该Filter默认在POST /login时启用。

重写attemptAuthentication，封装请求中的username和password，将认证交给AuthenticationManager，再交给对应的AuthenticationProvider认证即可。

重写successfulAuthentication，如果认证通过，在responseHeader中添加token



**添加JWT认证Filter**

继承OncePerRequestFilter，重写doFilterInternal方法。

将JWT解码验证，并将用户名&权限信息添加到SecurityContext中，交给Spring Seucurity来判断该用户是否有权限访问对应的接口。



**引入Java JWT库，用于加密解密JWT token**

https://github.com/jwtk/jjwt#install-jdk-maven

暂时使用一个简单的长字符串用于加密&解密，后续考虑采用RSA算法随机生成的非对称公钥私钥对。



**Spring Security Config**

关闭csrf，因为我们使用的是JWT authentication的方式，本身就自带一个header。

因为还没有给用户建库，所以暂时用于个FakeUserDetailService实现UserDetailsService，写几个固定的用户用于测试。



### 2022/4/20

**Spring Security Config**

自定义cors管理，自定义AllowedOrigins，AllowedMethods，AllowedHeaders，ExposedHeaders。

注意AllowedHeaders一定要将Content-type和Authentication添加进来，否则带有这些header的请求读不到。



**前端**

- 使用一个Hamburger作为手机版菜单展开按钮
- 增加用户登录的Modal
- 增加UserContext用于用户登陆状态&用户信息的管理

其他小处理

- 因为误触Modal外边可能导致关闭弹窗，设置一个X按钮用于关闭Modal
- 复用Modal，传入Width和Height用于自定义窗口大小
- 将导航栏改为fixed，然后给<main>添加一个margin-top即可拥有固定导航栏。main中的第一层div不要再使用margin-top了，改成padding-top，否则回导致margin collapse。



### 2022/4/21

**用户建模**

基础的用户名，密码，性别，地址...



正常登录：输入用户名密码，验证，发token

第三方登录：获取到第三方信息，拿到第三方id，没有现存用户就insert一个新的，发token



**引入react loader spinner做加载动画**

https://github.com/mhnpd/react-loader-spinner

每次切换页面后，使用useEffect()设置一个1~2秒的loading时间。

如果isLadoing === true，将屏幕用loading spinner代替，fixed top-0 left-0 w-full h-full。



**基础登录功能实现**

1. 使用点击登录是带着formdata请求/login接口
2. 获取到Authentication token后，放置到local storage
3. 再次请求User信息，放置到UserContext
4. navigate(0)刷新页面，渲染Header等用户信息相关组件



### 2022/4/26

**整理项目**

- 使用模板模式重构了爬虫接口的代码
- 增加先爬虫后处理，重写equals()，只将新爬到的内容持久化。
- 自定义一些Exception类，并自定义ExceptionHandler对其进行处理



**引入spring-boot-validator用来验证请求DTO中的数据**

https://www.baeldung.com/spring-boot-bean-validation

主要就是用@NotBlank, @NotEmpty；特殊的可以使用@Pattern, 	@Email...

设置defaultMessage，并在自定义ExceptionHandler取出，放到返回结果中。

> 更多注解查看这个包 package javax.validation.constraints;



TODO：无法自定义Spring Security抛出的异常



### 2022/4/27

**实现用户注册**

模态窗口支持在登录，注册，忘记密码这三个模式中相互跳转

注册：用户名，密码，邮箱

登录：用户名/邮箱，密码

忘记密码：邮箱（邮箱发送重置密码，待实现）



**用户退出**

删除token，清空全局user



**前端**

新增用户登录后的头像显示，和点击后的下拉菜单（用户空间，退出）



### 2022/4/28 ~ 4/29

**前端**

绘制用户空间，显示用户信息，推荐信息（待完成），收藏信息

用UserContext管理收藏状态



**后端**

新增后端Favorite表，同时关联User和Color，同时额外用Timestamp类保存收藏时间。

新增CRUD接口：查询所有收藏，添加收藏，删除收藏。



**整合**

在口红界面选中色号并点击空心星星，会从空心变为实心⭐，添加收藏。点击实心的星星，变为空心，删除收藏。

收藏后，可以在用户空间查看所有收藏的色号。

点击查看详情，进入口红界面并自动选中对应的色号。

点击删除，删除收藏。



### 2022/5/6

**学习websocket，使用该技术chat-room**

websocket是双向的，由ws开头，ws://www.google.com

开始时创建连接，双向通话，直到一方断开连接。

real time update, not needed when REST api is sufficient



**前端**

美化口红列表页面



### 2022/5/10

初步完成聊天系统，支持多人公共频道聊天（无数据库存储）

**引入spring-boot-starter-websocket**

https://spring.io/guides/gs/messaging-stomp-websocket/



**引入前端websocket相关包**

- sockjs-client https://github.com/sockjs/sockjs-client
- stompjs http://jmesnil.net/stomp-websocket/doc/
- net （一个stompjs的依赖包）



**axios.interceptor**

- 使用interceptor.request在调用“/user”接口前，统一携带token

- 使用interceptor.response统一处理403错误（通过setShowLoginModal(true)弹出登录框）

  解决无法在非functional componet中调用useContext()的问题

  https://stackoverflow.com/questions/64296505/usecontext-inside-axios-interceptor



**CORS问题**

`Access-Control-Allow-Credentials`需要在返回头中设置位true，否则websocket连接无法成功，原因是ws的连接依赖于credentials？

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials

解决方案：在spring-security的cors-config中添加`configuration.setAllowCredentials(true);`



### 2022/5/11

**私聊**

支持根据username去跳转subscribe和send，完成私聊功能

用户进入聊天室后自动subscribe自己的channel，其他人可以hover你的头像点击私聊，对你的channel发送消息



**前端**

使用timeInterval()和clearInterval(),hover发送信息的用户名0.3秒后显示该用户基本信息

并且提供“进入空间”（TODO）和“私聊”两个功能

通过useRef()，让聊天框自动下拉到最新信息



至此，使用2天时间完成了基本的websocket前后端交互，支持群聊&私聊。

后续，还需要增加数据库交互，发送口红信息等功能。



### 2022/5/12

**通过Oauth2完成Github登录功能**

Oauth流程：

1. 前端携带clientId到github登陆页面
2. 用户登录后redirect到前端，前端获取code，并向后端请求换token
3. 后端restTemplate post换取token（clientId + cliendSecret + code）
4. 后端restTemplate get获取userInfo，如果用户不存在就register一下（通过provider+username的方式判断），成功后返回并携带JWT token

通过@ConfigurationProperties动态根据provider获取对应信息（client_id, cliend_secret...)，这样的设计可以很好的scale，以后增加其他Oauth2登录方式时，只需增加一个接口和填写对应的配置类即可。



### 2022/5/13

### **完成GITHUB Oauth2登录功能**

文档很好，坑很少

https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

**数据存放**

固定信息如：providerName & tokenUri  & userUri 放在enum中

非固定信息如：client_id & client_secret & redirectUri 放在yml中

**Oauth2登录逻辑**

1. 前端已经拿到code，给到后端换token
2. 后端拿到token，请求用户信息
3. 查看是否有已存在账号，若存在则直接签名JWT返回
4. 为用户创建username&password，username若有重复，则随机添加后缀
5. 注册用户，签名JWT返回
6. 前端保存JWT，fetchUser，并refresh到上一个页面

> 整理后的前后端代码都非常简略，试图百搭所有Oauth登录
>
> 但后续发现还是最好为每个Oauth提供单独的接口或者策略模式，因为每个网站的实现都不太一样，返回的用户信息格式也不同（如google就返回email，需要我们手动生成username...）



### 2022/5/16

使用Github workflows处理后端CI/CD



### 2022/5/17

策划“色号推荐”功能

**筛选条件**

1. 品牌 + 价格
2. 类型
3. 色系：通过hue
4. 皮肤：

重新构造数据库：

- 对于color，需要保存rgb + hue + saturation + brightness
- 对于口红，需要额外保存类型（唇膏 or 口红...)
- 对于es数据库，更改refresh方法，直接获取hsb？

