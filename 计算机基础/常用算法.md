# 常用算法



# 1、排序算法

几个概念：

稳定性

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210526112242985.png" alt="image-20210526112242985" style="zoom:67%;" />

原地算法（In-place）：空间复杂度为O(1)的算法；非原地算法成为 Not-inplace / Out-of-place

抽取公共代码，sort()，swapCount，cmpCount



### 冒泡排序（Bubble Sort）

从头开始比较每一个相邻元素，如果第1个比第2个大，就交换他们的位置

执行完一轮后，最末尾的元素就是最大元素



**优化1：每一轮重置一个标记（假定完全有序true），如果一轮下来没有交换，说明完全有序了，直接break；如果进入交换，将标记设为false**

**注意：只有存在提前完全有序情况，才算优化；如果数据非常随机，则很难提前break**



**优化2：如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数；比完全有序的概率大得多！**



**优化之后，swap的次数不会变，只是会减少比较次数，提高效率。**



最坏、平均时间复杂度：O(n^2)

最好时间复杂度：O(n)

空间复杂度：O(1)

稳定



### 选择排序（Selection Sort）

找出最大的元素，和最末尾元素进行交换

执行完一轮后，最末尾的那个元素就是最大元素



为了稳定性（相同值的元素，排序前后的前后顺序一致），要注意！

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210526112709314.png" alt="image-20210526112709314" style="zoom:50%;" />	



**优化：使用堆来选择最大值，将选择最大值的过程从 O(n) 变成 O(logn)**



最好、最坏、平均时间复杂度：O(n^2)

空间复杂度：O(1)

可以是稳定排序！（很多人说是不稳定的，是因为实现方式是不稳定的）



### 堆排序（Heap Sort）

可以认为是对选择排序的一种优化

原地建堆（最大堆），将堆顶（最大值）和堆尾（下标为size-1）交换，size--，直到对元素数量为1



原地建堆 O(n)

循环排序：交换元素，size - 1，shiftdown，[O(1) + O(1) + O(logn)] * n

相加，O(1)和O(n)都被省略，得出O(nlogn)

最好、最坏、平均时间复杂度：O(nlogn)

不稳定



> 一个实验结果，在完全乱序的情况下，BubbleSort的两个优化反而让时间更慢了
>
> 随着更少的交换次数，SelectionSort效率更高
>
> 随着更少的比较次数，HeapSort效率最高
>
> <img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210526165000545.png" alt="image-20210526165000545" style="zoom:80%;" />	



### 插入排序（Insertion Sort）

插入排序会将序列分为2部分，头部是排好序的，尾部是待排序的

从头开始扫描每一个元素，将他插到头部合适的位置，使得头部数据保持有序



**逆序对**

逆序对越多，需要交换的元素就越多，效率也就越低！

![image-20210526170318919](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210526170318919.png)



最坏、平均时间复杂度：O(n^2) --> 每一个新插入的，都要交换到最前面，全是逆序对

最好时间复杂度：O(n) --> 完全升序，没有逆序对



**优化：将【交换】转为【挪动】**

将待插入的元素备份

头部有序数据中比待插入元素大的，都朝尾部挪动1个位置

逆序对越多，优化程度越大



**二分搜索（Binary Search）**

和二叉搜索树的概念类似

无序数组：从第0个位置开始遍历，平均 O(n)

有序数组：从中间元素开始比较，最坏 O(logn)

有多个重复值的时候，不确定返回哪一个



设计范围的时候，左闭右开

好处：比如0,1,2,3这个数组[0,4)，begin = 0，end = 4(array.length)，求数量直接end-begin



二分搜索返回的插入位置：找出第1个大于插入元素的元素的位置



### 归并排序（Merge Sort）

不断的将当前序列平均分成2个子序列，直到不能在分割（每个序列剩1个元素）

然后不断的将2个子序列合并成一个有序序列，直到只剩1个有序序列

devide & merge



begin和mid、mid和end --》 递归devide

begin，mid，end --》合并



归并排序的复杂度推导：有点东西，自己推一边玩玩

使用递推式，有一张递推式和复杂度的对应表

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210527162333696.png" alt="image-20210527162333696" style="zoom:50%;" />	



最好、最坏、平均时间复杂度 O(nlogn)

空间复杂度 O(n) --> 需要创建n/2的空间存放leftArray[]  

稳定



### 史上“最强”排序 - 休眠排序(段子)

开线程，每一个value时一个线程，值小的sleep的短！Thread.sleep(value)





### 快速排序（Quick Sort）

从序列中选择一个轴点元素（pivot）

利用pivot将序列分割成2个子序列（小于它的元素放左边，大于的放右边，等于无所谓）

重复操作



快速排序的本质：逐渐将每个元素都转换成轴点元素



构造轴点，begin，end，然后对比，begin < end 则 end覆盖begin++，反之 begin覆盖end--；第一步要将被覆盖的元素提取出来，之后就一直覆盖就行

注意：如果要左闭右开，end必须先--才能获得尾部元素



确定轴点位置：array[begin]作为轴点



轴点左右元素比较均匀：最好、平均时间复杂度O(nlogn)

轴点左右元素极度不均匀：最坏时间复杂度O(n^2)

降低最坏情况的出现概率，随机选择轴点元素

空间复杂度：O(logn)

不稳定排序



### 希尔排序（Shell Sort）

把序列看作是一个矩阵，分成m列，逐列进行排序

减少`逆序对`，希尔排序底层使用`插入排序`



希尔本人给出的步长序列：n/(2^k)，如果n=16，步长序列是：8，4，2，1

目前已知最好的步长序列，最坏情况时间复杂度是O(n^(4/3))，1986年由Robert Sedgewick提出



最好时间复杂度：O(n)

最坏时间复杂度：O(n^(4/3)) ~ O(n^2)

平均时间复杂度：取决于步长序列

空间复杂度：O(1)

不稳定排序



so far : 7种排序，3 more left

这7种都是基于比较的排序，都是在比谁大谁小，重要！

平均时间复杂度，最好 O(nlogn)



剩下的三种，典型的空间换时间，都不是基于比较，某些时候时间复杂度可以比 O(nlogn)更低

了解即可，开发和面试都很少涉猎（but I consider all three of them are really interesting)



### 计数排序（Counting Sort）

对一定范围内的整数进行排序

统计每个整数在序列中出现的次数，从而获得有序数组

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210528145239492.png" alt="image-20210528145239492" style="zoom:67%;" />	



极其浪费空间（根据数字最大值建立list，如果我们的数组从1000-2000，那么前1000个下位置的空间都浪费掉了）

无法对负数进行排序（下标从0开始）

时间复杂度：O(n)



**优化1：不仅找最大值，还找最小值；将空间改为 [max - min, max]，所需空间就是 max - min + 1；也可以对负整数进行排序了！**



**优化2：将次数改为累加次数；比如3出现2次，4出现3次，这时4的次数就写成5；这个次数不仅包含了该元素出现的次数，还可以推出它在序列中的位置**

**不便利count数组，而是遍历原有数组了！通过元素，获得count索引，通过次数获得array索引，解决不稳定的问题**



对自定义对象进行排序：如果自定义对象可以提供以排序的整数类型，依然可以使用计数排序



最好、最坏、平均时间复杂度：O(n + k)

空间复杂度：O(n + k)

k 是整数的取值范围

稳定排序



### 基数排序（Radix Sort）

所谓的基数，就是组成一个数的个位、十位、百位...

基数排序非常适合整数排序（尤其是非负整数），基于计数排序

依次对序列的个位数，十位数，百位数，...进行排序（从低位到高位）



最好、最坏、平均时间复杂度：O(d(n + k))，d是最大值的位数，k是进制（一般就是10，对应计数排序中的取值范围）；k虽然比较小，k还是不能省略，因为算个变量。

空间复杂度：O(d(n + k))

稳定排序



另一种思路：创建一个二维数组，也是从个位开始比较，然后从小到大遍历，再从十位开始比较...

10个桶，每个桶里有元素；再创建一个size[]，记录每个桶中的元素数量

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210528164149988.png" alt="image-20210528164149988" style="zoom:67%;" />	



### 桶排序（Bucket Sort）

创建一定数量的桶（使用数组、链表作为桶）

按照一定的规则，将序列中的元素均匀分配到对应的桶

对每个桶进行排序，遍历到序列中

![image-20210528173931900](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210528173931900.png)



桶排序仅仅是一种逻辑，其中的规则都是我们自己定的，不实现了。

时间复杂度：O(n + k)

空间复杂度：O(n + m) --> m是桶的数量

