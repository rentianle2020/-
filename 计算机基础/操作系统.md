# 处理机操作系统



### 1.1、操作系统的概念、功能和目标

概念：操作系统是一个软件。控制管理整个计算机的软硬件资源，并合理分配。给用户和其他软件提供接口。



**资源管理者**

提供的功能：文件管理，内存管理（程序放到内存），处理器管理（分配处理机资源给多个进程），设备管理（摄像头分配给进程）

目标：安全、高效



**用户和硬件的接口**

提供的功能：用户接口（命令接口 --> 用户直接使用，如DOS；程序接口 --> 用户通过程序间接使用）

目标：方便用户使用



**最接近硬件的软件**

对硬件机器的拓展，虚拟机



### 1.2、操作系统的特征

并发：多个事件“同时”发生，其实微观上是交替发生；多个进程并发，分配时间片

> 并行：多个事件同时发生



共享：资源供内存中多个并发执行的进程共同使用（互斥/“同时”），当然对于播放器，有的时候是确实在同时使用

> 并发和共享互为存在条件



虚拟：将1个物理实体变为若干个逻辑上的对应；空分复用技术（虚拟内存），时分复用技术（虚拟CPU）

异步：由于可分配资源有限，进程执行不是一贯到底，而是走走停停，速度不可预知

> 如果没有并发/共享，就谈不上虚拟和异步



### 1.3、操作系统的发展与分类

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210628171835238.png" alt="image-20210628171835238" style="zoom: 50%;" />	



### 1.4、操作系统的运行机制与体系结构



**两种指令、两种处理器状态、两种程序**

指令：特权指令（内存清零指令），非特权指令（普通的运算指令）

处理器状态：用户态（只能执行非特权指令），核心态（所有指令均可执行）

> 通过程序状态子寄存器（PSW）的某个标志位来表示当前CPU处于的状态，0为用户态，1为核心态

程序：内核程序（可执行所有指令，运行在核心态），应用程序（只能执行非特权指令，运行在用户态）



**操作系统的内核**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210708104720376.png" alt="image-20210708104720376" style="zoom: 40%;" />	

- 时钟管理
- 中断机制
- 原语：特殊的程序，最接近硬件，运行具有原子性
- 进程管理、内存管理、设备管理（不一定属于内核）

以上都包含，叫做大内核；只包括前三个，叫做微内核（需要频繁切换核心态/用户态，性能低；但结构清晰，方便维护）



### 1.5、中断和异常

发生中断，意味着操作系统介入开展管理工作，CPU会立即进入核心态（中断是从用户态到核心态的唯一途径）

核心态到用户态的切换是通过执行一个特权指令



内中断：信号来源于CPU内部，和当前执行的指令有关

- 陷入trap：有意而为之，系统调用
- 故障fault：由错误条件引起，可能被故障处理程序修复
- 终止abort：无法被修复的错误

外中断：信号来源于CPU外部，和当前执行的指令无关

CPU执行完每一条指令之后，都会检查是否有外部中断信号；如果被中断，立即保护被中断进程的CPU环境



### 1.6、系统调用

应用程序通过系统调用，来请求操作系统的服务。保证系统的稳定性和安全性。

系统调用是操作系统向上提供的接口；我们调用C/Java库函数，有时是对系统调用的封装，让应用程序可以更好的使用



传递系统调用参数 --> 执行陷入指令（用户态）int x --> 根据x陷入指令，执行响应服务（核心态）--> 返回用户程序

> 陷入指令是唯一一个只能在用户态执行，不能在核心态执行的指令



### 2.1、进程的定义、组成、组织、特征

经典定义：

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位



系统为每一个运行的程序配置一个进程控制块（PCB）+ 程序段（存放要执行的代码） + 数据段（存放程序运行中处理的各种数据） = 进程实体



**PCB**

- 进程描述信息：进程标识符PID（唯一ID），用户标识符UID（标识进程所属的用户）
- 进程控制和管理信息：进程状态&优先级
- 资源分配清单
- CPU相关信息：各种寄存器值，在进程切换时记录下来保存到PCB中



**进程的组织**

链接方式：执行指针，就绪队列指针，阻塞队列指针；这些指针指向队头

索引方式：指针指向索引表



**进程的特征**

- 动态性：进程是程序的一次执行过程，动态的产生、变化、消亡
- 独立性：独立运行，独立获得资源，独立接受调度的基本单位
- 结构性：程序段、数据段、PCB
- 并发性
- 异步性



### 2.2、进程的状态与转换



**三种基本状态**

- 运行态（Running）：单核每次最多只能有一个程序在运行态
- 就绪态（Ready）：具备运行条件，只不过没有空闲CPU
- 阻塞态（Waiting/Blocked)：因为某一时间，暂时不能运行



**另外两种状态**

- 创建态（New）：操作系统为进程分配资源，初始化PCB
- 终止态（Terminated）：操作系统回收资源



**进程状态的转换**

创建态 --> 就绪态（除了CPU以外的资源Ready）--> 运行态（如果时间片到了，回到就绪态） --> 阻塞态（用“系统调用”的方式申请某种系统资源，等待事件发生；进程自身做出的主动行为）--> 就绪态（被动行为）

进程运行结束，或遇到不可修复问题，就来到终止态

![image-20210628204059454](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210628204059454.png)



### 2.3、进程控制

对系统中所有的进程实施有效的管理

简单理解：实现进程状态转换



**进程控制通过原语来实现**

通过“关中断指令”和“开中断指令”（不让别人中断），使用原语执行原子操作

无论哪个原语，要做的无非三类事情：

1. 更新PCB中的信息

   修改进程状态、保存运行环境、恢复运行环境

2. 将PCB插入合适的队列

3. 分配/回收资源



相关原语：进程的创建、终止、阻塞&唤醒、切换



### 2.4、进程通信

顾名思义，就是指进程之间的信息交换

各进程拥有各自的内存地址空间，相互独立；为了保证安全，一个进程不能直接访问其他进程的地址空间

但信息交换又必须实现（比如从图片进程，分享图片到微信进程）



**共享存储**

操作系统为两个进程提供“共享空间”，访问是互斥的（通过P、V操作实现）



**消息传递**

以格式化消息（Message）为单位，通过“发送消息/接收消息”两个原语进行数据交互

通过将”消息体“挂到另一个进程的”缓冲队列“，来实现消息发送；类似网络协议包



**管道通信**

在内存中开辟的一个大小固定的缓冲区

![image-20210628210316724](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210628210316724.png)

1. 管道只能提供半双工通信（单向传输）；如果要实现双向同时通信，需要设置两个管道
2. 互斥的访问管道
3. 写满时，不能再写（阻塞）；读空时，不能再读（阻塞）
4. 没写满，不让读；没读空，不让写
5. 数据一旦被读出，就从管道中抛弃，所以读进程最多只能有一个



### 2.5、线程概念和多线程模型

有的进程可能需要“同时”做很多事，因此引入了线程，增加并发度。（QQ视频聊天，发送文件）



**线程的属性**

- 进程是资源分配的基本单位，线程是CPU调度的基本单位
- 同一进程的不同线程共享进程的资源（线程几乎不拥有系统资源）
- 同一进程中的线程切换不需要切换进程环境，系统开销小
- 每个进程也有一个TID，也有控制块TCB



用户级线程：从用户视角看的线程，由应用程序管理

内核级线程：从操作系统视角看的线程（内核级线程才是CPU分配的单位）



**多线程模型**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210629104217478.png" alt="image-20210629104217478" style="zoom:67%;" />	



### 3.1、处理机调度的概念、层次

从就绪队列中，按照一定的算法，选择一个进程并将处理机分配给它



调度的三个层次

高级调度（作业调度）：首次将作业从外存调入内存，建立PCB

中级调度：进程挂起到外存（PCB不会一起调到外存）；中级调度就是当该进程具备运行条件&内存空闲时，再次调回内存；提高内存利用率

> 七状态模型：在五状态之上，再添加两个状态：就绪挂起&阻塞挂起；程序在不同状态中挂起/激活

低级调度（进程调度）：选取进程，分配CPU给它；最基本的一种调度，频率超高



### 3.2、进程调度的时机、切换与过程、方式

- 当前进程主动放弃CPU
- 当前进程被迫放弃CPU（强行剥夺）



**进程的调度方式**

非剥夺调度方式：只允许进程主动放弃CPU（早期批处理系统）

剥夺调度方式：如果有更重要更紧迫的进程，立即暂停当前正在执行的进程（可以有限处理更紧急的进程）



**进程的切换与过程**

1. 原进程各种数据的保存
2. 新进程各种数据的恢复

进程的调度、切换是有代价的！



### 3.3、调度算法的评估

CPU利用率：忙碌时间/总时间

系统吞吐量：单位时间内完成作业的数量

周转时间、等待时间、响应时间



### 3.4、调度算法（上）

以下三种，不区分任务紧急程度，对于用户来说交互性糟糕，适用于早期的批处理系统



**先来先服务（First Come First Serve）**

选最先到达的作业/进程

公平、算法实现简单；对长作业有利，对短作业不利（等30分钟买20杯奶茶，或买1杯）；不会导致饥饿（进程一直拿不到资源）



**短作业有限（Shortest Job First）**

非抢占式的，选已经到达的，运行完时间最短的作业/进程；可以是抢占式的

对短作业有利，对长作业不利；有可能导致长作业饥饿



**高响应比有限（Highest Response Ratio Next）**

响应比 = （等待时间 + 要求服务时间） / 要求服务时间

选择执行响应比最高的

综合了前两个算法的优点；避免饥饿



### 3.5、调度算法（下）

用于分时操作系统，更注重响应时间



**时间片轮转（Round-Robin）**

用于进程调度，轮流让各个进程执行一个时间片（如100ms），属于抢占式算法；由时间中断来通知CPU时间片已到

公平、响应快；但需要高频率切换，不区分紧急程度



**优先级调度算法**

设置每一个作业/进程的优先级，调度时选择优先级最高的

通常：系统>用户进程；前台>后台；IO繁忙型优先（让IO设备尽早投入工作）；从公平角度，运行久的降低优先级，等待久的提升优先级



**多级反馈队列调度算法**

不同级别的队列，优先级从高到低，时间片分配从小到大

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210629153627732.png" alt="image-20210629153627732" style="zoom:67%;" />	

新进程先进入1级队列，如果进程还没有结束，就排到下一级队列；当1级队列为空，才会为2级队列分配时间片；平衡，但有可能导饥饿



### 4.1、进程同步、进程互斥

操作系统提供“进程同步”的服务，让进程按照一定的顺序协同进行（**有序进行**）

进程互斥，资源共享，一个时间段只允许一个进程访问该资源（临界资源），需要互斥的进行



进入区 --> 临界区 --> 退出区

临界区：访问临界资源的代码段

进入区和退出区：负责实现互斥的代码段（上锁，解锁）



**临界资源互斥访问的原则**

1. 空闲让进
2. 忙则等待
3. 有限等待；保证不饥饿
4. 让权等待；进不了临界区的进程，应立即释放CPU，防止忙等



### 4.2、进程互斥的软件实现方法

单标志法：违背空闲让进

双标志先检查法：多进程情况下，可能同时进入临界区，违反忙则等待

双标志后检查法：先上锁，后检查，可能都无法进入临界区；违背空闲让进和有限等待

Peterson算法：解决了上述问题，单依然不遵循“让权等待“原则

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210629161055313.png" alt="image-20210629161055313" style="zoom:67%;" />	



### 4.3、进程互斥的硬件实现方法



**中断屏蔽方法**

利用“开/关中断指令”实现

关中断 --> 临界区 --> 开中断



**TestAndSet指令 & Swap指令**

硬件实现，执行过程不可被中断



### 4.4、信号量机制

很好的解决进程互斥、进程同步的问题



信号量其实就是一个变量，可以用来表示系统中某种资源的数量

使用一对原语操作信号量：wait(S),signal(S)，S代表信号量；可以简写为P(S)，V(S)



**整形信号量**

用一个整数作为信号量，表示系统中某种资源的数量

不满足让权等待原则



**记录型信号量（重点）**

wait(S)申请资源，signal(S)释放资源；申请不到资源的进入等待队列，主动切换到阻塞状态（释放CPU，不会忙等！）；其他进程释放资源后，将队头进程出队，从阻塞态切换到就绪态，分配资源

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210629174037101.png" alt="image-20210629174037101" style="zoom:50%;" />	



### 4.5、用信号量实现同步

进程同步：让各个并发进程按照要求有序的进行，存在异步性

变量信号量设置为0，“前操作”之后执行V操作；“后操作”之前执行P操作

解决异步性的问题，让两个进程可以完成一前一后的操作



### **4.6 4.7、生产者-消费者问题**

生产者进程每次生产一个产品放入缓冲区；消费者进程每次从缓冲区取出一个产品并使用

互斥：访问缓冲区；同步（一前一后）：没资源了就要先生产后消费；满资源了就要先消费再生产



多生产者-多消费者：互斥问题同理；而同步问题变得复杂，抽象为事件，放入水果事件P，拿走水果事件V



### 4.8、抽烟者问题

每一个抽烟者进程，从桌子上拿走需要的那两个材料，卷成烟；供应者进程让每个抽烟者轮流抽烟

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630120222401.png" alt="image-20210630120222401" style="zoom:67%;" />	



### 4.9、读者-写者问题

共享文件、读者进程、写者进程

多个读者进程同时读取，不会产生任何副作用

写进程和其他任何进程都互斥

设置一个计数器，记录当前正在访问的读进程数；如果第一个开始读的，就加锁；最后一个结束的就解锁



### 4.10、哲学家进餐问题

一张桌子、5名哲学家（思考/吃饭）、5名哲学家左手和右手分别有1只筷子，需要这两个筷子才能吃饭；如果别的哲学家拿走了其中一只，就得阻塞；

每个进程需要持有两个临界资源；每个人都先拿左边，再拿右边，可能会出现死锁 

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630143150298.png" alt="image-20210630143150298" style="zoom:50%;" />	



### 4.11、管程

信号量机制存在的问题：编写程序困难，易出错

管程：一种更高级的同步机制；用来实现进程的互斥&同步



管程的基本特征：

1. 数据结构只能被管程提供的函数所修改
3. 每次只允许一个进程访问



Java中新建一个类

用synchronized描述一个函数，那么该函数同一时间段内只能被一个线程调用，解决互斥

多个线程进入该函数，需要排队等待；由编译器负责实现各进程互斥的进入管程中的过程（函数）

通过wait/notify，等待/唤醒操作以解决同步问题



### 5.1、死锁的概念

我爱你，你爱他，他爱她，她爱我...循环等待别人的:heart:



死锁：各个进程都等待对方手里的资源，导致各进程都堵塞，都无法向前推进

饥饿：长期得不到想要的资源，无法推进

死循环：某种进程遇到问题，跳不出循环



区别：

死锁是两个或以上的进程同时发生，发生在阻塞态；可能只有一个进程发生饥饿，阻塞态（拿不到IO）或者就绪态（拿不到CPU）；死循环可以是有资源的，运行态的

死锁和饥饿是管理者（OS）的问题，死循环是被管理者（程序猿）的问题



**死锁产生的必要条件**

- 互斥条件：对互斥资源的争抢（如哲学家的筷子、打印机），而内存、扬声器等允许多个进程同时访问的资源是不会导致死锁的

- 不剥夺条件：资源不能被其他进程强行夺走

- 请求和保持条件：请求被别的进程占有的资源，请求被阻塞，但对自己手里的资源保持不放

- 循环等待条件：资源的循环等待连（每个人都在等另一方释放资源）；

  死锁必定循环等待，而循环等待未必死锁（第六个哲学家出现，释放筷子资源）



**死锁的处理策略**

1. 预防死锁；破坏4个必要条件
2. 避免死锁（银行家算法）
3. 死锁的检测和解除；允许死锁发生，但是需要能检测并解除



### 5.2、静态策略：预防死锁

1. 破坏互斥条件：SPOOLing技术，将独占设备，在逻辑上改成共享设备

   可行性不高，很多时候无法破坏互斥条件

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630153717174.png" alt="image-20210630153717174" style="zoom:50%;" />	



2. 破化不剥夺条件：当进程请求新的资源而得不到满足时，主动释放/强行剥夺

   实现复杂；导致部分工作实效；反复申请释放开销大；可能饥饿

3. 破坏请求和保持条件：静态分配方法，投入运行后就持有所有资源直到结束，不会发出新的资源申请

   资源利用率低；可能饥饿

4. 破坏循环等待条件：顺序资源分配法，给资源编号，每个进程必须按照编号底层的顺序请求资源；持有小编号资源的进程等待大编号，不会有大编号资源的进程等待小编号，不会产生循环等待

   不方便添加新设备；资源浪费；编程麻烦



### 5.3、动态策略：避免死锁

银行家算法：在进程提出资源申请时，先判断此次分配是否会导致系统进入不安全状态。如果会，就暂时不答应请求，进程堵塞等待；找安全序列

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630162107113.png" alt="image-20210630162107113" style="zoom:50%;" />	

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630162027665.png" alt="image-20210630162027665" style="zoom:67%;" />	



### 5.4、死锁的检测和解除

死锁检测算法：依次消除与不阻塞进程相连的边，直到无边可消

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630163052891.png" alt="image-20210630163052891" style="zoom: 67%;" />	

死锁解除算法：

- 资源剥夺法：进程暂时挂起到外存
- 撤销进程法：强行剥夺进程资源
- 进程回退法：回退到足以避免死锁的地步



对谁下手？

1. 进程优先级
2. 已执行多长时间
3. 还要多久能完成
4. 进程已经使用了多少资源
5. 进程是交互式（正在和用户在交互）的的还是批处理式的



### 6.1、内存基础知识

用于存放数据的硬件。程序执行前需要先放到内存中，才能被CPU处理



多个程序并发，怎么区分各个程序的数据是放在什么地方？内存地址！

数量单位：4GB = 4*2^30，如果是按字节编址，就有2^32个“小房间”



CPU从内存中的程序段中取指令和参数地址，从数据段中取指定地址的数据

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630163830240.png" alt="image-20210630163830240" style="zoom:67%;" />	



编译：编译器使用的是逻辑地址；无法确认最后的物理地址（绝对地址）

链接：将多个目标模块组合成完整的逻辑地址

装入：将逻辑地址转换成绝对地址放入内存中；地址重定位采用“动态重定位”

​	<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630164117309.png" alt="image-20210630164117309" style="zoom:67%;" />

运行时动态链接：运行时需要目标模块才链接并装入内存（类加载器？）

动态重定位：装入内存时，装入程序将逻辑地址放入内存；系统设置一个重定位寄存器（存放程序的起始位置），当程序运行时，才动态的将逻辑地址转换为绝对地址

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630164618266.png" alt="image-20210630164618266" style="zoom: 40%;" />	



### 6.2、内存管理

操作系统需要对内存进行管理

1. 内存空间的分配与回收
2. 从逻辑上对内存空间进行扩充（虚拟内存）
3. 逻辑地址到物理地址的转换，让程序员无需关心硬件（动态重定位）
4. 内存保护，保证进程在各个内存中访问，不会越界访问

   <img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630170859548.png" alt="image-20210630170859548" style="zoom: 43%;" />	

### 6.3、覆盖与交换

从逻辑上对内存空间进行扩充

覆盖技术 --> 同一进程中

交换 --> 不同进程之间



**覆盖技术**

解决“程序大小超过物理内存综合”的问题

将程序分为多个段（多个模块），常用段放在“固定区”，调入后不再调出；不常用的段放在”覆盖区“，需要时调入，不用了调出

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210630172656874.png" alt="image-20210630172656874" style="zoom: 50%;" />	

根据程序的调用结构分配内存，对程序员不透明，已经退出历史舞台



**交换技术**

内存空间紧张时，将某些进程暂时换出外存，把外存具有运行条件的进程换入内存（中级调度）

> 暂时被换出外存的进程状态：挂起态（Suspend）
>
> 就绪态被换出外存 --> 就绪挂起
>
> 阻塞态被换出外存 --> 阻塞挂起



1. 放到外存（磁盘）的什么位置？

   磁盘分为”文件区”和“对换区”，文件区采用离散分配的方式，追求空间利用率；对换区采用连续分配方式，IO速度更快；所以换出到对换区

2. 什么时候交换？

   很多进程运行，内存吃紧（很多进程运行时发生缺页）；当负荷降低，就暂定换出

3. 应该换出哪些进程？

   优先换出阻塞进程；优先级别低的进程；驻留时间短的不会被换出（防止优先级低的进程被来回换入换出）

   PCB会常驻内存，插入到挂起队列（PCB中记录进程存储的外存地址）



### 6.4、连续分配管理方式

系统为用户分配连续的内存空间



**动态分区分配**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701104856373.png" alt="image-20210701104856373" style="zoom: 80%;" />	

数据结构：空闲分区表/空闲分区链

分配算法：动态分区分配算法



维护空闲分区表/空闲分区链：

回收时合并空闲分区，或者建立新的空闲分区（前后都没有空闲分区）

分配时减少空闲分区的值，或者删除空闲分区（正好占满，不空闲）

​	

> 没有内部碎片，但有外部碎片
>
> 内部碎片：分配给某进程的内存，部分没用上
>
> 外部碎片：内存中某些空闲分区，太小难以利用
>
> 可以通过紧凑（拼凑，Compaction）技术来解决外部碎片，挪动现有进程的在内存中的位置



### 6.5、动态分区分配算法

**首次适应算法**：从低地址开始找，找到第一个大小能满足的空闲分区；经常要先经过各种小分区；20 --> 10 --> 1，却还在首位，每次得走一遍这个碎片，但更有可能将后面的大分区被留下来（最佳适应算法的好处）

最佳适应算法：连续分配，为了保证“大进程“能有连续的大片空间，可以尽快留下大片空闲区，优先使用更小的空闲区；实现方法：空闲分区按容量从小到大链接；缺点：会留下很多外部碎片

最大适应算法：优先使用最大空闲区；大进程无处安放

邻近适应算法：循环链表，从上次查找结束的位置开始查找；因为它平衡了，导致大分区可能被用完（最大适应算法的缺点）



### 6.6、基本分页存储管理的基本概念

连续分配方式会产生碎片，内存利用率低；虽然可以使用”紧凑“技术处理，但是时间代价很高



非连续分配管理方式：为用户进程分配的可以是一些分散的内存空间

内存空间分为一个个大小相等的分区，称为”内存块“（页框）

将用户进程分为与内存块大小相等的一个个区域，称为”页“

一一对应，无序存放

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701110601127.png" alt="image-20210701110601127" style="zoom:50%;" />	



**地址转换**

1. 通过逻辑地址，算出页号
2. 通过页表，将页号映射实际的内存块的块号
3. 通过逻辑地址，算出业内偏移量
4. 物理地址 = 页面始址 + 页面偏移量



通过逻辑地址，找页号和页内偏移量

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701112339122.png" style="zoom: 67%;" />	

n位表示页内偏移量，则每个页面的大小为2^n个内存单元

m位表示页号，则进程允许拥有2^m个页面



每个进程对应一张页表，进程的每一页对应一个页表项（页号+块号，页号可省略）

比如一共有2^20个页号，就要用20位，也就是至少3字节表示

每个页表项的长度（块号）也就是3Byte，页号不用在页表项中显示

直到页表存放的起始地址+页表项长度*页号，就能得到页号对应的块号了



### 6.7、基本地址转换机构

页表起始地址F和页表长度M，存放在进程控制块（PCB）中，进程运行时将他们放到页表寄存器（PTR）

访问两次内存：页号&访问目标

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701120017377.png" alt="image-20210701120017377" style="zoom: 40%;" />	



### 6.8、具有快表的地址变换机构



**局部性原理**

时间局部性：执行某条指令/访问某条数据后，不久之后可能被再次执行/访问

空间局部性：访问了某个存储单元不久之后，附近的存储单元有可能被访问



减少页面的访问次数，联想寄存器（TLB，快表）；如果命中了，只需访问1次内存；如果快表已满，根据一定算法进行替换

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701145957825.png" alt="image-20210701145957825" style="zoom: 40%;" />	



### 6.9、两级页表

页表必须连续存放（为了省去页号），如果很大，则违背离散分配

使用两级页表的方式，先去查顶级页表，然后找出对应的二级页表的块号，然后去二级页表，查找对应的内存中的块号，然后去内存中根据偏移量取数据

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701153508292.png" alt="image-20210701153508292" style="zoom:40%;" />	



### 6.10、基本分段存储管理

与”分页“最大的区别：离散分配时，所分配的地址空间的基本单位不同



**分段**

根据自身逻辑关系，划分为若干个段；每个段在内存中占连续空间，可以互不相邻

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705162211727.png" alt="image-20210705162211727" style="zoom:67%;" />	



**段表**

和页表的作用类似，建立逻辑段-物理内存的映射关系

段表中多了一个段长，每个页的长度相同，但每个段的长度不同



**地址转换**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705163123385.png" alt="image-20210705163123385" style="zoom:40%;" />	



### 6.11、段页式管理方式

页是信息的物理单位，对用户不可见

段是信息的逻辑单位，分段对用户是可见的

分页：不会产生外部碎片，不方便按照逻辑模块实现信息的共享和保护

分段恰恰相反



分页+分段=段页式管理

先分段，再分页



### 7.1、虚拟内存的基本概念



**传统存储管理**

1. 一次性：

   作业必须一次性全部装入内存后，才能开始运行；大作业无法运行

   多道程序并发度下降

2. 驻留性：

   一旦作业装入内存，就会一直驻留在内存



**局部性原理的应用**

程序中存在大量循环（时间局部性，while循环中的i被一直赋值、取值、做++）

很多数据在内存中都是连续存放的，程序的指令也是顺序地在内存中存放（空间局部性，不仅数组a[]的100个值是连续存放的，a[i] = i;i++这两个指令也是连续存放的）

![image-20210701162332211](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701162332211.png)	

如何应用？高速缓冲技术！

将更频繁访问的数据放到更高速的存储器中，暂时不用的放到更低速的存储器中

进程运行中，表现出了时间/空间局部性；基于局部性原理，将很快用到的部分装入内存，暂时不用的留在外存；当访问信息不在内存时，将所需信息从外存调入内存；如果内存空间不够，操作系统负责将内存中暂时用不到的信息换出内存；用户看来比实际内存大得多，这就是虚拟内存

高速缓存/寄存器中（快表）



**虚拟内存特征**

1. 多次性

   作业运行时无需一次装入内存

2. 多换性

   作业运行时无需一直常驻内存

3. 虚拟性

   从逻辑上扩充了内存的容量



**如何实现虚拟内存技术**

连续分配 = 每次调入必须和上一次连接上，不方便实现

所以，虚拟内存技术，建立在离散分配的内存管理方式基础之上

额外功能：请求调页/段，页面/段置换功能



### 7.2、请求分页管理方式

需要直到每个页面是否已经存入内存

需要通过某种规则，决定换出哪个页面；如果页面修改过，需要写回外存，否则不需要

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210701172106212.png" alt="image-20210701172106212" style="zoom:80%;" />



**缺页中断机构**

页面不在内存，产生缺页中断（内中断：故障fault），由操作系统的缺页中断处理程序处理中断；缺页的进程阻塞，完成后再将其唤醒

一条指令可能产生多次缺页中断



### 7.3、页面置换算法

好的算法 = 更少的缺页率

缺页中断未必发生页面置换，可能还有空闲的内存块



**最佳置换算法（OPT，Optimal）**

淘汰的页面是在最长时间内不再被访问的页面；遍历进程后面需要访问的页面，最后出现页面的被弹出内存块；性能差



**先进先出置换算法（FIFO）**

淘汰最早进入内存的页面，队列：对头淘汰，队尾插入

> Belady 异常：为进程分配的物理块数增大，但缺页次数不减反增；只有FIFO会产生这种异常



**最近最近未使用置换算法（LRU，last recently used）**

逆向遍历，最后遍历到的，就是最久没有被访问过的内存块，淘汰掉

性能好，实现起来需要硬件支持，算法开销大



**时间置换算法（CLOCK）**

又可以称为：最近未使用算法（NRU，Not Recently Used）

页面组成循环队列，访问过后，将访问位从0变为1；需要替换时，如果是1，则变为0，如果未0，就淘汰掉

如果都是1，则需要扫描第二遍；长得很像一个时钟

![image-20210702205945871](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210702205945871.png)



**改进型CLOCK（改进NRU）**

优先淘汰没有被修改过的界面（无需写回外存，直接淘汰）

循环队列，用（访问位，修改位）的形式表示各页面状态；

1. 查找第一个（0，0）
2. 查找第一个（0，1），每次访问将访问位设置为0
3. 查找第一个（0，0），不修改任何标志位
4. 查找第一个（0，1），一定会找到了



### 7.4、页面分配策略



**驻留集**

给进程分配的物理块的集合；采用虚拟技术，一般小于进程的总大小

进程使用100个页面，驻留集=1，频繁缺页；驻留集=100，不会缺页，并发度下降，资源利用率低

CPU可以和IO并行，但是没有并发进程，降低了资源利用率



固定分配：驻留集大小固定

可变分配：分配适当数目的物理块，运行期间可以改变



局部置换：缺页时，选择进程自己的物理块进行置换

全局置换：操作系统将空闲物理块/别的进程的物理块置换到外存，再分配给缺页进程



固定分配局部置换（灵活度低）

可变分配全局置换：优先先择空闲物理块，没了，就分配其他未锁定的页面（内核代码的页被锁定）；不合理，只要缺页就分配新的物理块

可变分配局部置换：根据缺页频率，增加/减少物理块的分配



**何时调入页面**

预调页策略：根据局部性原则，调入若干相邻页面。目前预测成功率只有50%左右，主要用于进程的首次调用（运行前调用）

请求调页策略：在运行期间发现缺页时，才将所缺页面调入内存



**从何处调入页面**

外存（磁盘）分成两个区

对换区：连续分配，读写更快；

文件去：离散分配，读写更慢



如果对换区空间够大：运行前将相关数据复制到对换区，之后页面调入调出，在内存与对换区之间进行

如果对换区空间不大：不允许修改的数据直接从文件区读，允许修改的从对换区读写

UNIX方式：从文件区读，换出到对换区，下次需要时从对换区调入



**抖动现象**

页面频繁换入换出的现象，主要原因是分配给进程的物理块不够



**工作集**

在某段时间间隔内，进程实际访问页面的集合

通过工作集大小，决定驻留集大小；选择不在工作集中的页面进行淘汰



### 8.1、初识文件管理

文件：就是一组有意义的信息/数据集合

各种各样的文件，文件有哪些属性？文件内部的组织结构？文件之间如何组织？

从下往上，OS应向上层提供哪些功能，才能让用户、应用程序使用文件？

从上往下，文件怎么存放在外存（磁盘）上？



**文件属性**

文件名：同一目录下不允许有重名文件

标识符：区分文件的唯一标识（对用户毫无可读性）

文件类型：不同类型，不同的默认打开方式

位置：文件存放路径（让用户使用），外存中的地址（操作系统使用）

文件大小、创建时间、上次修改时间、文件所有者信息

保护信息：不同用户对文件的访问权限不同



**文件逻辑结构**

无结构文件（如txt）：由二进制/字符流组成，又称”流式文件“

有结构文件（如数据库表）：由一个个记录组成（数据行），每条记录有是由一个个数据项组成



**文件物理结构**

外存分为一个个相等的”块/磁盘块/物理块“

操作系统将逻辑地址，转换为外存的物理地址

文件在物理上的存放和组织



**文件之间的组织**

树状，根目录（C、D盘），分支上有目录（一种特殊的数据结构）和文件



**向上提供的功能**

create系统调用：创建文件

read系统调用：读文件（记事本软件通过操作系统提供的read功能，将数据读入）

write系统调用：写文件

delete系统调用：删除文件

open系统调用&close系统调用（这里的打开和关闭，和双击点×是不同的）：读写开始前open，读写结束后close

复制文件：create空文件，read到内存，write到新文件



**OS其他文件管理功能**

文件共享&文件保护



### 8.2、文件的逻辑结构

因为无结构文件单纯的是由一组二进制流组成，我们重点关注有结构文件



**有结构文件**

一条条记录组成

文件中的记录：定长记录 char，可变长记录 varchar

如果文件中是可变长记录，则无法实现随机存取



**顺序文件**

逻辑上：

文件中的记录，逻辑上一个接着一个顺序排列



物理上：

顺序存储：逻辑上相邻，物理上也相邻

- 串结构：记录之间与关键字无关；无法快速找到某个关键字对应的记录；增删记录简单
- 顺序结构：按章关键字顺序排列（索引）；可以快速二分法查找到某个关键字对应的记录；增删记录困难

> 链式存储：逻辑上相邻，物理上不一定相邻；无法实现随机存取，和链表类似



undo、redo日志，减少IO次数，以此减少增删改的开销



**索引文件**

实现可变长记录的随机访问

索引表本身就是一个定长记录的顺序文件

索引表表项包括索引号，长度，指针；我们可以快速找到对应的指针

主要用于对信息处理的及时性要求较高的场合



**多级索引顺序文件**

多级索引，B+树，进一步减少查找次数

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703194447152.png" alt="image-20210703194447152" style="zoom: 67%;" />	



### 8.3、文件目录（文件夹）



**文件控制块**

![image-20210703195747722](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703195747722.png)	

目录本身就是一种有结构文件，由一条条记录组成，每个记录对应一个该目录下的文件

目录中的记录，就是一个“文件控制块（FCB）“

FCB包括了文件的基本信息（文件名、物理地址...）

FCB最重要、最基本服务：提供了文件名&文件物理地址的映射关系



**对目录的操作**

搜索：搜索目录项

创建文件：创建目录项

删除文件：删除目录项

显示目录：当前目录中所有文件和属性

修改目录：更改响应的目录项



**目录结构**

单机目录结构：系统中只有一个目录；不同的用户，都不允许文件重名

两级目录结构：主文件目录&用户文件目录；允许不同用户的文件重名



多级目录结构（树形目录结构）：

每个目录下，可以有更低级的目录和文件；不同目录下的文件可以是重名的

从根目录往下寻找，绝对路径；设置一个”当前目录“，从当前目录出发，相对路径，减少此片IO次数



无环图目录结构

树形结构不便于实现文件的共享，因此提出了”无环图目录结构“

支持不同的文件名，指向同一个文件；为了删除文件，设置一个”共享计数器“，当计数器为0时，才会将文件真正的删除

![image-20210703200711152](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703200711152.png)



**索引结点（FCB的改进）**

除了文件名外的所有信息，都放到索引节点，每个文件对应一个

目录项只存放文件名&索引结点指针，减少检索文件时的IO次数



输入文件名 --> 目录项中，根据文件名找到索引结点指针 --> 根据指针找到文件



### 8.4、文件的物理结构

对存放了文件数据的磁盘块的管理；即：文件的数据应该怎样存放在外存中？

内存与磁盘之间的数据交流，都是以”块“为单位



想要访问文件内的数据，使用逻辑地址：（逻辑块号，块内地址）的形式

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703202215689.png" alt="image-20210703202215689" style="zoom:70%;" />	

**连续分配**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703203355093.png" alt="image-20210703203355093" style="zoom:67%;" />	

物理块号 = 起始块号 + 逻辑块号

随机访问，磁头移动少，读写速度快，但不方便文件的拓展，产生磁盘碎片



**链接分配**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703203918885.png" alt="image-20210703203918885" style="zoom:67%;" />	

分为隐式链接（通过指针，如上图）&显示连接（文件分配表FAT中统一存放指针关系）

通过链表的方式连接，获取起始块号，然后开始顺序访问

文件方便拓展，不会产生碎片；显示连接不用多次访问磁盘，而是通过表来确定位置，支持随机访问



**索引分配**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703204634331.png" alt="image-20210703204634331" style="zoom:67%;" />	

类似内存中的页表，记录了逻辑块号到物理块号的映射关系（物理块号大小固定，逻辑块号可以隐藏）

如果索引表太大，一个索引块装不下怎么办？

多个索引块，链表链接（如果文件很大，这个链表从头开始读的效率也很低）

多层索引（类似于多级页表）

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703205223445.png" alt="image-20210703205223445" style="zoom:80%;" />	

访问1026号逻辑块，1026/256 = 4，1026%256 = 2

混合索引（对于小文件更友好）

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210703205444243.png" alt="image-20210703205444243" style="zoom:80%;" />	



### 8.5、文件存储空间管理

一个物理磁盘划分成多个逻辑磁盘 - 文件卷C（C盘） --> 分为目录去和文件区 --> 目录去存放FCB，用于管理；文件区存放文件数据



**空闲表法**

适用于连续分配方式，表中的属性为“第一个空闲盘块号”&“空闲盘块数”

分配时可以采用首次适应、最佳适应、最坏适应算法

回收时注意表项的合并



**空闲链表法**

空闲盘块链：OS保存链头、链尾的指针，每个块中指向下一块

空闲盘区链：OS保存链头链尾指针，连续的空闲盘块组成一个空闲盘区，每个区中的第一个块记录了盘区的长度和下一个盘区的指针



**位示图法**

每个二进制位对应一个盘块，0代表空闲，1代表已分配

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210704175943181.png" alt="image-20210704175943181" style="zoom:80%;" />	



**组成链接法**

UNIX系统采用

文件卷的目录中用一个磁盘块作为”超级块“

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210704181555483.png" alt="image-20210704181555483" style="zoom:67%;" />	



### 8.6、文件的基本操作



**创建文件**

create 系统调用，需要提供几个主要参数

1. 所需外存空间大小
2. 文件路径
3. 文件名

OS处理create系统调用：

1. 在外存中找到文件所需的空间
2. 在目录中创建文件对应的目录项



**删除文件**

delete 系统调用，参数为路径+文件名；OS找到目录项，回收磁盘块，删除目录项



**打开文件**

open 系统调用，参数为路径、文件名和操作类型（读&写）；OS找到目录项，检查权限，将目录项复制到内存中的”打开文件表“中（提升文件访问速度）

整个系统有一张单独的”打开文件表“，有一个打开记录器，记录几个进程打开了这个文件

每个进程也会有进程自己的”打开文件表“，指向系统的打开文件表



读写指针，记录读写操作进行到的位置

访问权限记录了打开文件时声明的权限，如”只读“

​	<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210704202814833.png" alt="image-20210704202814833" style="zoom:67%;" />



**关闭文件**

删除进程打开文件表对应的表项

打开计数器--

如果为0，就删除系统表的该表项



**读文件**

read 系统调用，先打开文件，再指明打开文件表的索引号（编号），读入多少数据，读入的数据存放在内存的位置



**写文件**

write 系统调用，指明打开文件表的索引号（编号），写出多少数据，写出外存的数据存放在内存的位置



### 8.7、文件共享

基于索引节点的共享方式（硬链接）：各个用户的目录项，指向同一个索引节点

基于符号链的共享方式（软连接）：建立一个Link类型文件，记录了共享文件的存放路径，类似”快捷方式“（需要一层层查询目录，多次磁盘IO）

共享意味着系统中只有”一份“文件数据，一个人修改，其他人都能看到数据变化；和”复制“不同



### 8.8、文件保护



**口令**

为文件设置一个”口令”（如：abc112233），存放在FCB或索引节点；用户访问前需要输入“口令”，OS进行对比

口令保存在系统，保密性差，但是效率高



**加密保护**

将文件数据进行加密

密码只有用户知道，保密性强，编码解码费时



**访问控制**

每个文件的FCB或索引节点中，增加一个访问控制表，记录用户权限；实现灵活

Windows的访问控制，文件-属性-安全



### 8.9、文件系统的层次结构

1. 用户接口：提供系统调用的接口
2. 文件目录系统：通过用户提供的路径，找到FCB或索引节点
3. 存取控制模块：验证用户访问权限，完成文件保护
4. 逻辑文件系统与文件信息缓冲区：将索引表带入缓冲区，然后查询索引表，得到逻辑地址
5. 物理文件系统：查询实际的物理地址
6. 辅助分配模块，分配和回收存储空间 OR 设备管理模块 --> 设备



例子：删除“D:/工作目录/学生信息.xlsx"的最后100条记录

1. 发出请求
2. OS找到目录项
3. OS验证删除权限
4. 得到记录对应的逻辑地址
5. 砖面成实际的物理地址
6. 向磁盘发出请求
7. 回收空闲盘块



### 9.1、磁盘的结构



**盘面**

磁盘由磁性物质组成，可以用这些磁物质来记录二进制数据

盘面被分为一个个磁道，一个磁盘有成千上万个磁道

盘面又被划分为一个个扇区，每个扇区就是一个磁盘块，各个扇区存放的数据量相同（如1KB）

最内侧磁道上的扇区面积最小，因此数据密度最大

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210704211122780.png" alt="image-20210704211122780" style="zoom:50%;" />	



**磁盘**

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210704211514211.png" alt="image-20210704211514211" style="zoom:50%;" />	

磁盘块 = （柱面号，盘面号，扇区号）

根据柱面号移动磁臂；激活指定盘面的磁头；磁盘旋转，指定的扇区从磁头下划过，完成读写



**磁盘的分类**

活动头磁盘，固定头磁盘（每个磁道有一个磁头）

可换盘磁盘，固定盘磁盘



### 9.2、磁盘调度算法



**一次磁盘读写所需要的时间**

寻道时间：启动磁头臂+移动磁头（跨越一个磁道0.2ms，共跨越n条磁道）

延迟时间：通过旋转磁盘，磁头定位到目标山区所需的时间（7200转/分），转速越快，延迟越小

传输时间：磁盘读写所需的时间（每个磁道存储N个字节，本次读写b个字节，转速r，(1/r)*(b/N))，转速越快，传输时间越短



操作系统无法优化延迟时间&传输时间，因为它们和转速线性相关

但操作系统的磁盘调度算法，直接影响寻道时间（移动磁头所花的时间）



**先来先服务算法（FCFS）**

根据进程请求到达的先后，依次的响应

公平，但若请求访问的磁道很分散，性能差



**最短寻道时间优先（SSTF）**

优先选择与当前磁头最近的磁道（选择眼前最优，贪心算法）

性能较好，但可能产生”饥饿“（磁头一直在一个小范围内移动）



**扫描算法（SCAN）**

电梯算法，磁头移动到最内侧之后，才能往内移动

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705102010466.png" alt="image-20210705102010466" style="zoom:67%;" />	



**LOOK调度算法**

对扫描算法的优化

如果在磁头移动方向上已经没有别的请求，立刻调转磁头移动方向



**循环扫描算法（C-SCAN）**

对扫描算法的优化

返回时，快速达到起始端，不处理任何请求；对各个请求响应很平均了

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705102257973.png" alt="image-20210705102257973" style="zoom:67%;" />	



**C-LOOOK调度算法**

LOOK和C-SCAN算法的结合

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705102350814.png" alt="image-20210705102350814" style="zoom:50%;" />	



### 9.3、减少磁盘延迟时间的方法

磁头读取完一个扇区后，需要一小段时间处理；所以如果逻辑上相邻的扇区物理上也相邻，可能需要等到下一圈，很高的”延迟时间“



**交替编号**

让逻辑上相邻的扇区，物理上有一定的间隔



**错位命名**

让相邻盘面的扇区编号”错位“



### 9.4、磁盘管理



**磁盘初始化**

1. 物理格式化：将各个磁道划分为扇区

   一个扇区分为头、数据区域、尾部

2. 磁盘分区（C盘、D盘）

3. 逻辑格式化：创建文件系统、根目录



**引导块**

ROM中存放很小的”自举装入程序“，出场写入，不能再修改

完整的自举程序放在磁盘的引导块上，拥有引导块的磁盘称为系统磁盘（C盘）



**坏块的管理**

硬件故障，OS无法修复

简单的磁盘：逻辑格式化时将坏块标记出来

对于复杂的磁盘：磁盘控制器维护一个坏块链



### 10.1、IO设备的概念和分类

输入/输出设备



**按照信息交换的单位分类**

块设备（传输快，可寻址）磁盘等

字符设备（传输满，不可寻址，常采用中断驱动方式）鼠标键盘等





### 10.2、IO控制器

IO设备的一个电子部件，作为CPU和IO设备机械部件之间的”中介“



**IO控制器的功能**

- 接收CPU发出的命令（控制寄存器存放read/write等命令）
- 向CPU报告设备的状态
- 数据交换（数据寄存器）
- 地址识别



**IO控制器的组成**

![image-20210705112434413](C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705112434413.png)



**寄存器的编址方式**

- 与内存统一编址，采用对内存进行操作的指令来操作控制器
- 独立编址，需要专门的指令来操作控制器



### 10.3、IO控制方式

- 程序直接控制方式：CPU发出IO命令后，不断轮询
- 中断驱动方式：CPU发出IO命令后可以做其他事，IO完成后，设备控制器发出中断信号
- DMA方式：CPU发出IO命令后可以做其他事，由DMA控制器直接和内存交互，完成后发出中断信号
- 通道控制方法：与DMA不同的是，通道是一个硬件设备，可以看作一个”弱鸡版CPU“

减少CPU对IO过程的干预，让CPU从繁杂的IO控制中解脱，更多的去完成数据处理任务



### 10.4、IO软件层次结构

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705114644175.png" alt="image-20210705114644175" style="zoom:50%;" />	

中间三个层次属于OS内核部分，即”IO系统“



用户层软件：实现了与用户交互的接口，库函数；通过系统调用，申请操作系统内核的服务

设备独立性软件：向上提供统一的调用接口，设备保护（设备看作一种特殊的文件），驱动程序映射

设备驱动程序：由于不同设备的寄存器等内部硬件不同，驱动程序由厂家提供，为了让操作系统可以控制硬件；驱动程序一般会以独立进程的方式存在

中断处理程序

硬件：执行IO操作，由机械部件、电子部件组成



### 10.5、假脱机技术

脱离主机的控制进行输入/输出操作

假脱机系统，又称SPOOLing技术，用软件的方式模拟脱机技术

<img src="C:\Users\乐乐大哥哥\AppData\Roaming\Typora\typora-user-images\image-20210705120014524.png" alt="image-20210705120014524" style="zoom:67%;" />	



**共享打印机的原理分析**

打印机是一种”独占式设备“，但可以用SPOOLing技术改造成”共享设备“

1. 在磁盘上申请一个缓冲区，将要打印的数据送入其中
2. 将打印请求挂到打印任务队列
3. 打印机空闲时，从对头取出一个打印请求，从磁盘缓冲区读出数据，送到输出缓冲区，再传输到打印机进行打印



### 10.6、设备的分配与回收



### 10.7、缓冲区

一般利用内存作为缓冲区

缓解CPU与设备的速度矛盾，价绍CPU的中断频率，提高CPU与IO设备之间的并行性